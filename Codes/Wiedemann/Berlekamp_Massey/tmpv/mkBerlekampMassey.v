//
// Generated by Bluespec Compiler, version 2014.05.C (build 33930, 2014-05-28)
//
// On Tue May  8 03:45:18 IST 2018
//
//
// Ports:
// Name                         I/O  size props
// RDY_start                      O     1 const
// RDY_polynomial__write          O     1 reg
// polynomial__read               O     4 reg
// RDY_polynomial__read           O     1 reg
// RDY_poly_length__write         O     1 reg
// poly_length__read              O    32 reg
// RDY_poly_length__read          O     1 reg
// outputValid                    O    32 reg
// RDY_outputValid                O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// start_s_in                     I     4 reg
// polynomial__write_1            I     4
// poly_length__write_1           I    32
// EN_start                       I     1
// EN_polynomial__write           I     1
// EN_poly_length__write          I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkBerlekampMassey(CLK,
			 RST_N,

			 start_s_in,
			 EN_start,
			 RDY_start,

			 polynomial__write_1,
			 EN_polynomial__write,
			 RDY_polynomial__write,

			 polynomial__read,
			 RDY_polynomial__read,

			 poly_length__write_1,
			 EN_poly_length__write,
			 RDY_poly_length__write,

			 poly_length__read,
			 RDY_poly_length__read,

			 outputValid,
			 RDY_outputValid);
  input  CLK;
  input  RST_N;

  // action method start
  input  [3 : 0] start_s_in;
  input  EN_start;
  output RDY_start;

  // action method polynomial__write
  input  [3 : 0] polynomial__write_1;
  input  EN_polynomial__write;
  output RDY_polynomial__write;

  // value method polynomial__read
  output [3 : 0] polynomial__read;
  output RDY_polynomial__read;

  // action method poly_length__write
  input  [31 : 0] poly_length__write_1;
  input  EN_poly_length__write;
  output RDY_poly_length__write;

  // value method poly_length__read
  output [31 : 0] poly_length__read;
  output RDY_poly_length__read;

  // value method outputValid
  output [31 : 0] outputValid;
  output RDY_outputValid;

  // signals for module outputs
  wire [31 : 0] outputValid, poly_length__read;
  wire [3 : 0] polynomial__read;
  wire RDY_outputValid,
       RDY_poly_length__read,
       RDY_poly_length__write,
       RDY_polynomial__read,
       RDY_polynomial__write,
       RDY_start;

  // register b
  reg [3 : 0] b;
  wire [3 : 0] b$D_IN;
  wire b$EN;

  // register c
  reg [3 : 0] c;
  reg [3 : 0] c$D_IN;
  wire c$EN;

  // register l
  reg [31 : 0] l;
  reg [31 : 0] l$D_IN;
  wire l$EN;

  // register m
  reg [31 : 0] m;
  wire [31 : 0] m$D_IN;
  wire m$EN;

  // register out_en
  reg out_en;
  wire out_en$D_IN, out_en$EN;

  // register outputDone
  reg [31 : 0] outputDone;
  wire [31 : 0] outputDone$D_IN;
  wire outputDone$EN;

  // register s
  reg [3 : 0] s;
  wire [3 : 0] s$D_IN;
  wire s$EN;

  // register state
  reg [1 : 0] state;
  reg [1 : 0] state$D_IN;
  wire state$EN;

  // register x
  reg [31 : 0] x;
  wire [31 : 0] x$D_IN;
  wire x$EN;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_l$write_1__VAL_3, MUX_x$write_1__VAL_2;
  wire [3 : 0] MUX_c$write_1__VAL_3;
  wire MUX_c$write_1__SEL_3, MUX_l$write_1__SEL_3, MUX_state$write_1__SEL_3;

  // remaining internal signals
  wire [31 : 0] l_PLUS_1___d4,
		m_PLUS_1___d36,
		x_8_MINUS_1___d42,
		x_8_PLUS_1___d39,
		x__h1185,
		x__h1298,
		x__h1412,
		x__h1526,
		x__h765,
		x__h848,
		x__h931;
  wire [3 : 0] IF_x_8_MINUS_1_2_BIT_31_6_THEN_c_2_BITS_3_TO_1_ETC___d55,
	       IF_x_8_MINUS_1_2_SLT_1_5_THEN_IF_x_8_MINUS_1_2_ETC___d64,
	       IF_x_8_MINUS_1_2_SLT_2_4_THEN_IF_x_8_MINUS_1_2_ETC___d73,
	       result__h1028,
	       result__h1050,
	       result__h1072,
	       result__h1094;
  wire IF_l_PLUS_1_SLE_1_THEN_s_BIT_m_BITS_1_TO_0_0_1_ETC___d19,
       IF_l_PLUS_1_SLE_2_THEN_IF_l_PLUS_1_SLE_1_THEN__ETC___d26,
       IF_l_PLUS_1_SLE_3_THEN_IF_l_PLUS_1_SLE_2_THEN__ETC___d33,
       discrepancy__h586,
       discrepancy__h606,
       discrepancy__h626,
       l_BITS_30_TO_0_4_CONCAT_0_5_SLT_m_PLUS_1_6___d37,
       x__h640,
       y__h601,
       y__h621,
       y__h641,
       y__h677,
       y__h769,
       y__h852;

  // action method start
  assign RDY_start = 1'd1 ;

  // action method polynomial__write
  assign RDY_polynomial__write = out_en ;

  // value method polynomial__read
  assign polynomial__read = c ;
  assign RDY_polynomial__read = out_en ;

  // action method poly_length__write
  assign RDY_poly_length__write = out_en ;

  // value method poly_length__read
  assign poly_length__read = l ;
  assign RDY_poly_length__read = out_en ;

  // value method outputValid
  assign outputValid = outputDone ;
  assign RDY_outputValid = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_c$write_1__SEL_3 =
	     state == 2'd1 &&
	     IF_l_PLUS_1_SLE_3_THEN_IF_l_PLUS_1_SLE_2_THEN__ETC___d33 ;
  assign MUX_l$write_1__SEL_3 =
	     state == 2'd1 &&
	     IF_l_PLUS_1_SLE_3_THEN_IF_l_PLUS_1_SLE_2_THEN__ETC___d33 &&
	     l_BITS_30_TO_0_4_CONCAT_0_5_SLT_m_PLUS_1_6___d37 ;
  assign MUX_state$write_1__SEL_3 = state == 2'd1 && m == 32'd3 ;
  assign MUX_c$write_1__VAL_3 =
	     ((x_8_MINUS_1___d42 ^ 32'h80000000) < 32'h80000003) ?
	       result__h1028 :
	       IF_x_8_MINUS_1_2_SLT_2_4_THEN_IF_x_8_MINUS_1_2_ETC___d73 ;
  assign MUX_l$write_1__VAL_3 = m_PLUS_1___d36 - l ;
  assign MUX_x$write_1__VAL_2 =
	     IF_l_PLUS_1_SLE_3_THEN_IF_l_PLUS_1_SLE_2_THEN__ETC___d33 ?
	       (l_BITS_30_TO_0_4_CONCAT_0_5_SLT_m_PLUS_1_6___d37 ?
		  32'd1 :
		  x_8_PLUS_1___d39) :
	       x_8_PLUS_1___d39 ;

  // register b
  assign b$D_IN = c ;
  assign b$EN = MUX_l$write_1__SEL_3 ;

  // register c
  always@(EN_start or
	  EN_polynomial__write or
	  polynomial__write_1 or MUX_c$write_1__SEL_3 or MUX_c$write_1__VAL_3)
  case (1'b1)
    EN_start: c$D_IN = 4'd1;
    EN_polynomial__write: c$D_IN = polynomial__write_1;
    MUX_c$write_1__SEL_3: c$D_IN = MUX_c$write_1__VAL_3;
    default: c$D_IN = 4'b1010 /* unspecified value */ ;
  endcase
  assign c$EN =
	     state == 2'd1 &&
	     IF_l_PLUS_1_SLE_3_THEN_IF_l_PLUS_1_SLE_2_THEN__ETC___d33 ||
	     EN_polynomial__write ||
	     EN_start ;

  // register l
  always@(EN_start or
	  EN_poly_length__write or
	  poly_length__write_1 or
	  MUX_l$write_1__SEL_3 or MUX_l$write_1__VAL_3)
  case (1'b1)
    EN_start: l$D_IN = 32'd0;
    EN_poly_length__write: l$D_IN = poly_length__write_1;
    MUX_l$write_1__SEL_3: l$D_IN = MUX_l$write_1__VAL_3;
    default: l$D_IN = 32'hAAAAAAAA /* unspecified value */ ;
  endcase
  assign l$EN =
	     state == 2'd1 &&
	     IF_l_PLUS_1_SLE_3_THEN_IF_l_PLUS_1_SLE_2_THEN__ETC___d33 &&
	     l_BITS_30_TO_0_4_CONCAT_0_5_SLT_m_PLUS_1_6___d37 ||
	     EN_poly_length__write ||
	     EN_start ;

  // register m
  assign m$D_IN = (EN_start || state == 2'd2) ? 32'd0 : m_PLUS_1___d36 ;
  assign m$EN = state == 2'd1 || state == 2'd2 || EN_start ;

  // register out_en
  assign out_en$D_IN = 1'd1 ;
  assign out_en$EN = state == 2'd2 ;

  // register outputDone
  assign outputDone$D_IN = 32'd1 ;
  assign outputDone$EN = state == 2'd2 ;

  // register s
  assign s$D_IN = start_s_in ;
  assign s$EN = EN_start ;

  // register state
  always@(EN_start or state or MUX_state$write_1__SEL_3)
  case (1'b1)
    EN_start: state$D_IN = 2'd1;
    state == 2'd2: state$D_IN = 2'd0;
    MUX_state$write_1__SEL_3: state$D_IN = 2'd2;
    default: state$D_IN = 2'b10 /* unspecified value */ ;
  endcase
  assign state$EN = state == 2'd1 && m == 32'd3 || state == 2'd2 || EN_start ;

  // register x
  assign x$D_IN = EN_start ? 32'd1 : MUX_x$write_1__VAL_2 ;
  assign x$EN = state == 2'd1 || EN_start ;

  // remaining internal signals
  assign IF_l_PLUS_1_SLE_1_THEN_s_BIT_m_BITS_1_TO_0_0_1_ETC___d19 =
	     ((l_PLUS_1___d4 ^ 32'h80000000) <= 32'h80000001) ?
	       x__h640 :
	       discrepancy__h626 ;
  assign IF_l_PLUS_1_SLE_2_THEN_IF_l_PLUS_1_SLE_1_THEN__ETC___d26 =
	     ((l_PLUS_1___d4 ^ 32'h80000000) <= 32'h80000002) ?
	       IF_l_PLUS_1_SLE_1_THEN_s_BIT_m_BITS_1_TO_0_0_1_ETC___d19 :
	       discrepancy__h606 ;
  assign IF_l_PLUS_1_SLE_3_THEN_IF_l_PLUS_1_SLE_2_THEN__ETC___d33 =
	     ((l_PLUS_1___d4 ^ 32'h80000000) <= 32'h80000003) ?
	       IF_l_PLUS_1_SLE_2_THEN_IF_l_PLUS_1_SLE_1_THEN__ETC___d26 :
	       discrepancy__h586 ;
  assign IF_x_8_MINUS_1_2_BIT_31_6_THEN_c_2_BITS_3_TO_1_ETC___d55 =
	     x_8_MINUS_1___d42[31] ? result__h1094 : c ;
  assign IF_x_8_MINUS_1_2_SLT_1_5_THEN_IF_x_8_MINUS_1_2_ETC___d64 =
	     ((x_8_MINUS_1___d42 ^ 32'h80000000) < 32'h80000001) ?
	       result__h1072 :
	       IF_x_8_MINUS_1_2_BIT_31_6_THEN_c_2_BITS_3_TO_1_ETC___d55 ;
  assign IF_x_8_MINUS_1_2_SLT_2_4_THEN_IF_x_8_MINUS_1_2_ETC___d73 =
	     ((x_8_MINUS_1___d42 ^ 32'h80000000) < 32'h80000002) ?
	       result__h1050 :
	       IF_x_8_MINUS_1_2_SLT_1_5_THEN_IF_x_8_MINUS_1_2_ETC___d64 ;
  assign discrepancy__h586 =
	     IF_l_PLUS_1_SLE_2_THEN_IF_l_PLUS_1_SLE_1_THEN__ETC___d26 ^
	     y__h601 ;
  assign discrepancy__h606 =
	     IF_l_PLUS_1_SLE_1_THEN_s_BIT_m_BITS_1_TO_0_0_1_ETC___d19 ^
	     y__h621 ;
  assign discrepancy__h626 = x__h640 ^ y__h641 ;
  assign l_BITS_30_TO_0_4_CONCAT_0_5_SLT_m_PLUS_1_6___d37 =
	     ({ l[30:0], 1'd0 } ^ 32'h80000000) <
	     (m_PLUS_1___d36 ^ 32'h80000000) ;
  assign l_PLUS_1___d4 = l + 32'd1 ;
  assign m_PLUS_1___d36 = m + 32'd1 ;
  assign result__h1028 =
	     { IF_x_8_MINUS_1_2_SLT_2_4_THEN_IF_x_8_MINUS_1_2_ETC___d73[3] ^
	       b[x__h1526[1:0]],
	       IF_x_8_MINUS_1_2_SLT_2_4_THEN_IF_x_8_MINUS_1_2_ETC___d73[2:0] } ;
  assign result__h1050 =
	     { IF_x_8_MINUS_1_2_SLT_1_5_THEN_IF_x_8_MINUS_1_2_ETC___d64[3],
	       IF_x_8_MINUS_1_2_SLT_1_5_THEN_IF_x_8_MINUS_1_2_ETC___d64[2] ^
	       b[x__h1412[1:0]],
	       IF_x_8_MINUS_1_2_SLT_1_5_THEN_IF_x_8_MINUS_1_2_ETC___d64[1:0] } ;
  assign result__h1072 =
	     { IF_x_8_MINUS_1_2_BIT_31_6_THEN_c_2_BITS_3_TO_1_ETC___d55[3:2],
	       IF_x_8_MINUS_1_2_BIT_31_6_THEN_c_2_BITS_3_TO_1_ETC___d55[1] ^
	       b[x__h1298[1:0]],
	       IF_x_8_MINUS_1_2_BIT_31_6_THEN_c_2_BITS_3_TO_1_ETC___d55[0] } ;
  assign result__h1094 = { c[3:1], c[0] ^ b[x__h1185[1:0]] } ;
  assign x_8_MINUS_1___d42 = x - 32'd1 ;
  assign x_8_PLUS_1___d39 = x + 32'd1 ;
  assign x__h1185 = 32'd0 - x ;
  assign x__h1298 = 32'd1 - x ;
  assign x__h1412 = 32'd2 - x ;
  assign x__h1526 = 32'd3 - x ;
  assign x__h640 = s[m[1:0]] ;
  assign x__h765 = m - 32'd1 ;
  assign x__h848 = m - 32'd2 ;
  assign x__h931 = m - 32'd3 ;
  assign y__h601 = c[3] & y__h852 ;
  assign y__h621 = c[2] & y__h769 ;
  assign y__h641 = c[1] & y__h677 ;
  assign y__h677 = s[x__h765[1:0]] ;
  assign y__h769 = s[x__h848[1:0]] ;
  assign y__h852 = s[x__h931[1:0]] ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        b <= `BSV_ASSIGNMENT_DELAY 4'd1;
	c <= `BSV_ASSIGNMENT_DELAY 4'd1;
	l <= `BSV_ASSIGNMENT_DELAY 32'd0;
	m <= `BSV_ASSIGNMENT_DELAY 32'd0;
	out_en <= `BSV_ASSIGNMENT_DELAY 1'd0;
	s <= `BSV_ASSIGNMENT_DELAY 4'd0;
	state <= `BSV_ASSIGNMENT_DELAY 2'd0;
	x <= `BSV_ASSIGNMENT_DELAY 32'd1;
      end
    else
      begin
        if (b$EN) b <= `BSV_ASSIGNMENT_DELAY b$D_IN;
	if (c$EN) c <= `BSV_ASSIGNMENT_DELAY c$D_IN;
	if (l$EN) l <= `BSV_ASSIGNMENT_DELAY l$D_IN;
	if (m$EN) m <= `BSV_ASSIGNMENT_DELAY m$D_IN;
	if (out_en$EN) out_en <= `BSV_ASSIGNMENT_DELAY out_en$D_IN;
	if (s$EN) s <= `BSV_ASSIGNMENT_DELAY s$D_IN;
	if (state$EN) state <= `BSV_ASSIGNMENT_DELAY state$D_IN;
	if (x$EN) x <= `BSV_ASSIGNMENT_DELAY x$D_IN;
      end
    if (outputDone$EN) outputDone <= `BSV_ASSIGNMENT_DELAY outputDone$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    b = 4'hA;
    c = 4'hA;
    l = 32'hAAAAAAAA;
    m = 32'hAAAAAAAA;
    out_en = 1'h0;
    outputDone = 32'hAAAAAAAA;
    s = 4'hA;
    state = 2'h2;
    x = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkBerlekampMassey

