//
// Generated by Bluespec Compiler, version 2014.05.C (build 33930, 2014-05-28)
//
// On Fri May  4 10:07:23 IST 2018
//
//
// Ports:
// Name                         I/O  size props
// RDY_wiedemann_in               O     1 const
// RDY_wiedemann_out__write       O     1 reg
// wiedemann_out__read            O     3 reg
// RDY_wiedemann_out__read        O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// wiedemann_out__write_1         I     3
// EN_wiedemann_in                I     1
// EN_wiedemann_out__write        I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkWiedemann(CLK,
		   RST_N,

		   EN_wiedemann_in,
		   RDY_wiedemann_in,

		   wiedemann_out__write_1,
		   EN_wiedemann_out__write,
		   RDY_wiedemann_out__write,

		   wiedemann_out__read,
		   RDY_wiedemann_out__read);
  input  CLK;
  input  RST_N;

  // action method wiedemann_in
  input  EN_wiedemann_in;
  output RDY_wiedemann_in;

  // action method wiedemann_out__write
  input  [2 : 0] wiedemann_out__write_1;
  input  EN_wiedemann_out__write;
  output RDY_wiedemann_out__write;

  // value method wiedemann_out__read
  output [2 : 0] wiedemann_out__read;
  output RDY_wiedemann_out__read;

  // signals for module outputs
  wire [2 : 0] wiedemann_out__read;
  wire RDY_wiedemann_in, RDY_wiedemann_out__read, RDY_wiedemann_out__write;

  // register c
  reg [2 : 0] c;
  wire [2 : 0] c$D_IN;
  wire c$EN;

  // register done
  reg done;
  wire done$D_IN, done$EN;

  // register mul
  reg [2 : 0] mul;
  wire [2 : 0] mul$D_IN;
  wire mul$EN;

  // register n
  reg [31 : 0] n;
  wire [31 : 0] n$D_IN;
  wire n$EN;

  // register s
  reg [2 : 0] s;
  wire [2 : 0] s$D_IN;
  wire s$EN;

  // register state
  reg [2 : 0] state;
  reg [2 : 0] state$D_IN;
  wire state$EN;

  // register t
  reg [2 : 0] t;
  wire [2 : 0] t$D_IN;
  wire t$EN;

  // register x
  reg [2 : 0] x;
  wire [2 : 0] x$D_IN;
  wire x$EN;

  // ports of submodule ifc
  wire [2 : 0] ifc$get, ifc$put_x;
  wire ifc$EN_put;

  // ports of submodule ifc2
  wire [31 : 0] ifc2$poly_length__write_1;
  wire [2 : 0] ifc2$polynomial__read,
	       ifc2$polynomial__write_1,
	       ifc2$start_s_in;
  wire ifc2$EN_poly_length__write,
       ifc2$EN_polynomial__write,
       ifc2$EN_start,
       ifc2$RDY_polynomial__read;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_n$write_1__VAL_2;
  wire [2 : 0] MUX_state$write_1__VAL_4;
  wire MUX_c$write_1__SEL_1;

  // remaining internal signals
  wire [2 : 0] x__h691, y__h1136;
  wire x__h745, x__h760, y__h746, y__h761;

  // action method wiedemann_in
  assign RDY_wiedemann_in = 1'd1 ;

  // action method wiedemann_out__write
  assign RDY_wiedemann_out__write = done ;

  // value method wiedemann_out__read
  assign wiedemann_out__read = c ;
  assign RDY_wiedemann_out__read = done ;

  // submodule ifc
  mkBMVM ifc(.CLK(CLK),
	     .RST_N(RST_N),
	     .put_x(ifc$put_x),
	     .EN_put(ifc$EN_put),
	     .get(ifc$get),
	     .RDY_get(),
	     .RDY_put());

  // submodule ifc2
  mkBerlekampMassey ifc2(.CLK(CLK),
			 .RST_N(RST_N),
			 .poly_length__write_1(ifc2$poly_length__write_1),
			 .polynomial__write_1(ifc2$polynomial__write_1),
			 .start_s_in(ifc2$start_s_in),
			 .EN_start(ifc2$EN_start),
			 .EN_polynomial__write(ifc2$EN_polynomial__write),
			 .EN_poly_length__write(ifc2$EN_poly_length__write),
			 .RDY_start(),
			 .RDY_polynomial__write(),
			 .polynomial__read(ifc2$polynomial__read),
			 .RDY_polynomial__read(ifc2$RDY_polynomial__read),
			 .RDY_poly_length__write(),
			 .poly_length__read(),
			 .RDY_poly_length__read(),
			 .outputValid(),
			 .RDY_outputValid());

  // inputs to muxes for submodule ports
  assign MUX_c$write_1__SEL_1 = ifc2$RDY_polynomial__read && state == 3'd5 ;
  assign MUX_n$write_1__VAL_2 = n + 32'd1 ;
  assign MUX_state$write_1__VAL_4 =
	     ((n ^ 32'h80000000) < 32'h80000003) ? 3'd1 : 3'd4 ;

  // register c
  assign c$D_IN =
	     MUX_c$write_1__SEL_1 ?
	       ifc2$polynomial__read :
	       wiedemann_out__write_1 ;
  assign c$EN = EN_wiedemann_out__write || MUX_c$write_1__SEL_1 ;

  // register done
  assign done$D_IN = 1'd1 ;
  assign done$EN = MUX_c$write_1__SEL_1 ;

  // register mul
  assign mul$D_IN = EN_wiedemann_in ? 3'b101 : ifc$get ;
  assign mul$EN = state == 3'd2 || EN_wiedemann_in ;

  // register n
  assign n$D_IN = EN_wiedemann_in ? 32'd0 : MUX_n$write_1__VAL_2 ;
  assign n$EN = state == 3'd2 || EN_wiedemann_in ;

  // register s
  assign s$D_IN = (x__h745 ^ y__h746) ? s | x__h691 : s & y__h1136 ;
  assign s$EN = state == 3'd1 ;

  // register state
  always@(EN_wiedemann_in or
	  state or MUX_c$write_1__SEL_1 or MUX_state$write_1__VAL_4)
  case (1'b1)
    EN_wiedemann_in: state$D_IN = 3'd1;
    state == 3'd4: state$D_IN = 3'd5;
    MUX_c$write_1__SEL_1: state$D_IN = 3'd0;
    state == 3'd3: state$D_IN = MUX_state$write_1__VAL_4;
    state == 3'd2: state$D_IN = 3'd3;
    state == 3'd1: state$D_IN = 3'd2;
    default: state$D_IN = 3'b010 /* unspecified value */ ;
  endcase
  assign state$EN =
	     state == 3'd3 || MUX_c$write_1__SEL_1 || EN_wiedemann_in ||
	     state == 3'd1 ||
	     state == 3'd2 ||
	     state == 3'd4 ;

  // register t
  assign t$D_IN = 3'b110 ;
  assign t$EN = EN_wiedemann_in ;

  // register x
  assign x$D_IN = 3'b101 ;
  assign x$EN = EN_wiedemann_in ;

  // submodule ifc
  assign ifc$put_x = mul ;
  assign ifc$EN_put = state == 3'd1 ;

  // submodule ifc2
  assign ifc2$poly_length__write_1 = 32'h0 ;
  assign ifc2$polynomial__write_1 = 3'h0 ;
  assign ifc2$start_s_in = s ;
  assign ifc2$EN_start = state == 3'd4 ;
  assign ifc2$EN_polynomial__write = 1'b0 ;
  assign ifc2$EN_poly_length__write = 1'b0 ;

  // remaining internal signals
  assign x__h691 = 3'd1 << n ;
  assign x__h745 = x__h760 ^ y__h761 ;
  assign x__h760 = mul[0] & t[0] ;
  assign y__h1136 = ~x__h691 ;
  assign y__h746 = mul[2] & t[2] ;
  assign y__h761 = mul[1] & t[1] ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        c <= `BSV_ASSIGNMENT_DELAY 3'd0;
	done <= `BSV_ASSIGNMENT_DELAY 1'd0;
	mul <= `BSV_ASSIGNMENT_DELAY 3'd0;
	n <= `BSV_ASSIGNMENT_DELAY 32'd0;
	s <= `BSV_ASSIGNMENT_DELAY 3'd0;
	state <= `BSV_ASSIGNMENT_DELAY 3'd0;
	t <= `BSV_ASSIGNMENT_DELAY 3'd0;
	x <= `BSV_ASSIGNMENT_DELAY 3'd0;
      end
    else
      begin
        if (c$EN) c <= `BSV_ASSIGNMENT_DELAY c$D_IN;
	if (done$EN) done <= `BSV_ASSIGNMENT_DELAY done$D_IN;
	if (mul$EN) mul <= `BSV_ASSIGNMENT_DELAY mul$D_IN;
	if (n$EN) n <= `BSV_ASSIGNMENT_DELAY n$D_IN;
	if (s$EN) s <= `BSV_ASSIGNMENT_DELAY s$D_IN;
	if (state$EN) state <= `BSV_ASSIGNMENT_DELAY state$D_IN;
	if (t$EN) t <= `BSV_ASSIGNMENT_DELAY t$D_IN;
	if (x$EN) x <= `BSV_ASSIGNMENT_DELAY x$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    c = 3'h2;
    done = 1'h0;
    mul = 3'h2;
    n = 32'hAAAAAAAA;
    s = 3'h2;
    state = 3'h2;
    t = 3'h2;
    x = 3'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (state == 3'd2) $display("s= %b", s[n[1:0]]);
  end
  // synopsys translate_on
endmodule  // mkWiedemann

