//
// Generated by Bluespec Compiler, version 2014.05.C (build 33930, 2014-05-28)
//
// On Thu May  3 17:49:24 IST 2018
//
//
// Ports:
// Name                         I/O  size props
// get                            O    32 reg
// RDY_get                        O     1 reg
// RDY_put                        O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// put_x                          I    32 reg
// EN_put                         I     1
// EN_get                         I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkEllBMVM(CLK,
		 RST_N,

		 EN_get,
		 get,
		 RDY_get,

		 put_x,
		 EN_put,
		 RDY_put);
  parameter [31 : 0] lut_num = 32'b0;
  input  CLK;
  input  RST_N;

  // actionvalue method get
  input  EN_get;
  output [31 : 0] get;
  output RDY_get;

  // action method put
  input  [31 : 0] put_x;
  input  EN_put;
  output RDY_put;

  // signals for module outputs
  wire [31 : 0] get;
  wire RDY_get, RDY_put;

  // inlined wires
  wire [25 : 0] lut_serverAdapter_outData_outData$wget;
  wire [1 : 0] lut_serverAdapter_s1_1$wget;
  wire lut_serverAdapter_cnt_1$whas,
       lut_serverAdapter_outData_enqData$whas,
       lut_serverAdapter_outData_outData$whas,
       lut_serverAdapter_writeWithResp$whas;

  // register in
  reg [31 : 0] in;
  wire [31 : 0] in$D_IN;
  wire in$EN;

  // register lut_serverAdapter_cnt
  reg [2 : 0] lut_serverAdapter_cnt;
  wire [2 : 0] lut_serverAdapter_cnt$D_IN;
  wire lut_serverAdapter_cnt$EN;

  // register lut_serverAdapter_s1
  reg [1 : 0] lut_serverAdapter_s1;
  wire [1 : 0] lut_serverAdapter_s1$D_IN;
  wire lut_serverAdapter_s1$EN;

  // register out
  reg [31 : 0] out;
  wire [31 : 0] out$D_IN;
  wire out$EN;

  // register row_num
  reg [4 : 0] row_num;
  reg [4 : 0] row_num$D_IN;
  wire row_num$EN;

  // register state
  reg [1 : 0] state;
  reg [1 : 0] state$D_IN;
  wire state$EN;

  // ports of submodule in_fifo
  wire [31 : 0] in_fifo$D_IN, in_fifo$D_OUT;
  wire in_fifo$CLR, in_fifo$DEQ, in_fifo$EMPTY_N, in_fifo$ENQ, in_fifo$FULL_N;

  // ports of submodule lut_memory
  wire [25 : 0] lut_memory$DI, lut_memory$DO;
  wire [4 : 0] lut_memory$ADDR;
  wire lut_memory$EN, lut_memory$WE;

  // ports of submodule lut_serverAdapter_outDataCore
  wire [25 : 0] lut_serverAdapter_outDataCore$D_IN,
		lut_serverAdapter_outDataCore$D_OUT;
  wire lut_serverAdapter_outDataCore$CLR,
       lut_serverAdapter_outDataCore$DEQ,
       lut_serverAdapter_outDataCore$EMPTY_N,
       lut_serverAdapter_outDataCore$ENQ,
       lut_serverAdapter_outDataCore$FULL_N;

  // ports of submodule out_fifo
  wire [31 : 0] out_fifo$D_IN, out_fifo$D_OUT;
  wire out_fifo$CLR,
       out_fifo$DEQ,
       out_fifo$EMPTY_N,
       out_fifo$ENQ,
       out_fifo$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_complete,
       WILL_FIRE_RL_initiateBMVM,
       WILL_FIRE_RL_lut_serverAdapter_outData_enqAndDeq,
       WILL_FIRE_RL_receive;

  // inputs to muxes for submodule ports
  wire [4 : 0] MUX_row_num$write_1__VAL_2;
  wire [1 : 0] MUX_state$write_1__VAL_1;
  wire MUX_lut_memory$put_1__SEL_1, MUX_state$write_1__SEL_1;

  // remaining internal signals
  wire [31 : 0] x__h2618, y__h9394;
  wire [4 : 0] x__h9373;
  wire [3 : 0] IF_x359_OR_lut_serverAdapter_outData_outDataw_ETC__q1;
  wire [2 : 0] lut_serverAdapter_cnt_6_PLUS_IF_lut_serverAdap_ETC___d32;
  wire [1 : 0] ab__h1850;
  wire lut_serverAdapter_cnt_6_SLT_3___d61,
       x__h2677,
       x__h2692,
       x__h2707,
       x__h2722,
       x__h2794,
       x__h4435,
       x__h6076,
       x__h6359,
       x__h6361,
       x__h6363,
       x__h6699,
       x__h6701,
       x__h6703,
       x__h7043,
       x__h7045,
       x__h7047,
       x__h7717,
       x__h9028,
       x__h9030,
       x__h9032,
       y__h2678,
       y__h2693,
       y__h2708,
       y__h2723,
       y__h4436,
       y__h6077,
       y__h7718;

  // actionvalue method get
  assign get = out_fifo$D_OUT ;
  assign RDY_get = out_fifo$EMPTY_N ;

  // action method put
  assign RDY_put = in_fifo$FULL_N ;

  // submodule in_fifo
  FIFO2 #(.width(32'd32), .guarded(32'd1)) in_fifo(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(in_fifo$D_IN),
						   .ENQ(in_fifo$ENQ),
						   .DEQ(in_fifo$DEQ),
						   .CLR(in_fifo$CLR),
						   .D_OUT(in_fifo$D_OUT),
						   .FULL_N(in_fifo$FULL_N),
						   .EMPTY_N(in_fifo$EMPTY_N));

  // submodule lut_memory
  BRAM1Load #(.FILENAME("../ELL_BMVM/LUT/ell4.mem"),
	      .PIPELINED(1'd0),
	      .ADDR_WIDTH(32'd5),
	      .DATA_WIDTH(32'd26),
	      .MEMSIZE(6'd32),
	      .BINARY(1'd1)) lut_memory(.CLK(CLK),
					.ADDR(lut_memory$ADDR),
					.DI(lut_memory$DI),
					.WE(lut_memory$WE),
					.EN(lut_memory$EN),
					.DO(lut_memory$DO));

  // submodule lut_serverAdapter_outDataCore
  SizedFIFO #(.p1width(32'd26),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(32'd1)) lut_serverAdapter_outDataCore(.RST(RST_N),
							     .CLK(CLK),
							     .D_IN(lut_serverAdapter_outDataCore$D_IN),
							     .ENQ(lut_serverAdapter_outDataCore$ENQ),
							     .DEQ(lut_serverAdapter_outDataCore$DEQ),
							     .CLR(lut_serverAdapter_outDataCore$CLR),
							     .D_OUT(lut_serverAdapter_outDataCore$D_OUT),
							     .FULL_N(lut_serverAdapter_outDataCore$FULL_N),
							     .EMPTY_N(lut_serverAdapter_outDataCore$EMPTY_N));

  // submodule out_fifo
  FIFO2 #(.width(32'd32), .guarded(32'd1)) out_fifo(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(out_fifo$D_IN),
						    .ENQ(out_fifo$ENQ),
						    .DEQ(out_fifo$DEQ),
						    .CLR(out_fifo$CLR),
						    .D_OUT(out_fifo$D_OUT),
						    .FULL_N(out_fifo$FULL_N),
						    .EMPTY_N(out_fifo$EMPTY_N));

  // rule RL_initiateBMVM
  assign WILL_FIRE_RL_initiateBMVM =
	     in_fifo$EMPTY_N && lut_serverAdapter_cnt_6_SLT_3___d61 &&
	     state == 2'd0 ;

  // rule RL_complete
  assign WILL_FIRE_RL_complete = out_fifo$FULL_N && state == 2'd3 ;

  // rule RL_receive
  assign WILL_FIRE_RL_receive =
	     (row_num == 5'd0 && state == 2'd2 ||
	      lut_serverAdapter_cnt_6_SLT_3___d61 &&
	      (lut_serverAdapter_outDataCore$EMPTY_N ||
	       lut_serverAdapter_outData_enqData$whas) &&
	      lut_serverAdapter_outData_outData$whas) &&
	     (state == 2'd1 || state == 2'd2) ;

  // rule RL_lut_serverAdapter_outData_enqAndDeq
  assign WILL_FIRE_RL_lut_serverAdapter_outData_enqAndDeq =
	     lut_serverAdapter_outDataCore$EMPTY_N &&
	     lut_serverAdapter_outDataCore$FULL_N &&
	     MUX_lut_memory$put_1__SEL_1 &&
	     lut_serverAdapter_outData_enqData$whas ;

  // inputs to muxes for submodule ports
  assign MUX_lut_memory$put_1__SEL_1 =
	     WILL_FIRE_RL_receive && (row_num != 5'd0 || state != 2'd2) ;
  assign MUX_state$write_1__SEL_1 = WILL_FIRE_RL_receive && row_num == 5'd0 ;
  assign MUX_row_num$write_1__VAL_2 = row_num + 5'd1 ;
  assign MUX_state$write_1__VAL_1 = (state == 2'd2) ? 2'd3 : 2'd2 ;

  // inlined wires
  assign lut_serverAdapter_outData_enqData$whas =
	     (!lut_serverAdapter_s1[0] ||
	      lut_serverAdapter_outDataCore$FULL_N) &&
	     lut_serverAdapter_s1[1] &&
	     lut_serverAdapter_s1[0] ;
  assign lut_serverAdapter_outData_outData$wget =
	     lut_serverAdapter_outDataCore$EMPTY_N ?
	       lut_serverAdapter_outDataCore$D_OUT :
	       lut_memory$DO ;
  assign lut_serverAdapter_outData_outData$whas =
	     lut_serverAdapter_outDataCore$EMPTY_N ||
	     !lut_serverAdapter_outDataCore$EMPTY_N &&
	     lut_serverAdapter_outData_enqData$whas ;
  assign lut_serverAdapter_cnt_1$whas =
	     (MUX_lut_memory$put_1__SEL_1 || WILL_FIRE_RL_initiateBMVM) &&
	     (!ab__h1850[1] || ab__h1850[0]) ;
  assign lut_serverAdapter_writeWithResp$whas =
	     MUX_lut_memory$put_1__SEL_1 || WILL_FIRE_RL_initiateBMVM ;
  assign lut_serverAdapter_s1_1$wget =
	     { 1'd1, !ab__h1850[1] || ab__h1850[0] } ;

  // register in
  assign in$D_IN = in_fifo$D_OUT ;
  assign in$EN = WILL_FIRE_RL_initiateBMVM ;

  // register lut_serverAdapter_cnt
  assign lut_serverAdapter_cnt$D_IN =
	     lut_serverAdapter_cnt_6_PLUS_IF_lut_serverAdap_ETC___d32 ;
  assign lut_serverAdapter_cnt$EN =
	     lut_serverAdapter_cnt_1$whas || MUX_lut_memory$put_1__SEL_1 ;

  // register lut_serverAdapter_s1
  assign lut_serverAdapter_s1$D_IN =
	     { lut_serverAdapter_writeWithResp$whas &&
	       lut_serverAdapter_s1_1$wget[1],
	       lut_serverAdapter_s1_1$wget[0] } ;
  assign lut_serverAdapter_s1$EN = 1'd1 ;

  // register out
  assign out$D_IN = (x__h2677 ^ y__h2678) ? out | x__h2618 : out & y__h9394 ;
  assign out$EN = MUX_lut_memory$put_1__SEL_1 ;

  // register row_num
  always@(MUX_lut_memory$put_1__SEL_1 or
	  MUX_row_num$write_1__VAL_2 or
	  WILL_FIRE_RL_initiateBMVM or WILL_FIRE_RL_complete)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_lut_memory$put_1__SEL_1: row_num$D_IN = MUX_row_num$write_1__VAL_2;
      WILL_FIRE_RL_initiateBMVM: row_num$D_IN = MUX_row_num$write_1__VAL_2;
      WILL_FIRE_RL_complete: row_num$D_IN = 5'd0;
      default: row_num$D_IN = 5'b01010 /* unspecified value */ ;
    endcase
  end
  assign row_num$EN =
	     WILL_FIRE_RL_receive && (row_num != 5'd0 || state != 2'd2) ||
	     WILL_FIRE_RL_initiateBMVM ||
	     WILL_FIRE_RL_complete ;

  // register state
  always@(MUX_state$write_1__SEL_1 or
	  MUX_state$write_1__VAL_1 or
	  WILL_FIRE_RL_complete or WILL_FIRE_RL_initiateBMVM)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_state$write_1__SEL_1: state$D_IN = MUX_state$write_1__VAL_1;
      WILL_FIRE_RL_complete: state$D_IN = 2'd0;
      WILL_FIRE_RL_initiateBMVM: state$D_IN = 2'd1;
      default: state$D_IN = 2'b10 /* unspecified value */ ;
    endcase
  end
  assign state$EN =
	     WILL_FIRE_RL_receive && row_num == 5'd0 ||
	     WILL_FIRE_RL_complete ||
	     WILL_FIRE_RL_initiateBMVM ;

  // submodule in_fifo
  assign in_fifo$D_IN = put_x ;
  assign in_fifo$ENQ = EN_put ;
  assign in_fifo$DEQ = WILL_FIRE_RL_initiateBMVM ;
  assign in_fifo$CLR = 1'b0 ;

  // submodule lut_memory
  assign lut_memory$ADDR = row_num ;
  assign lut_memory$DI =
	     MUX_lut_memory$put_1__SEL_1 ?
	       26'b10101010101010101010101010 /* unspecified value */  :
	       26'b10101010101010101010101010 /* unspecified value */  ;
  assign lut_memory$WE = 1'd0 ;
  assign lut_memory$EN =
	     WILL_FIRE_RL_receive && (row_num != 5'd0 || state != 2'd2) ||
	     WILL_FIRE_RL_initiateBMVM ;

  // submodule lut_serverAdapter_outDataCore
  assign lut_serverAdapter_outDataCore$D_IN = lut_memory$DO ;
  assign lut_serverAdapter_outDataCore$ENQ =
	     WILL_FIRE_RL_lut_serverAdapter_outData_enqAndDeq ||
	     lut_serverAdapter_outDataCore$FULL_N &&
	     !MUX_lut_memory$put_1__SEL_1 &&
	     lut_serverAdapter_outData_enqData$whas ;
  assign lut_serverAdapter_outDataCore$DEQ =
	     WILL_FIRE_RL_lut_serverAdapter_outData_enqAndDeq ||
	     lut_serverAdapter_outDataCore$EMPTY_N &&
	     MUX_lut_memory$put_1__SEL_1 &&
	     !lut_serverAdapter_outData_enqData$whas ;
  assign lut_serverAdapter_outDataCore$CLR = 1'b0 ;

  // submodule out_fifo
  assign out_fifo$D_IN = out ;
  assign out_fifo$ENQ = WILL_FIRE_RL_complete ;
  assign out_fifo$DEQ = EN_get ;
  assign out_fifo$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_x359_OR_lut_serverAdapter_outData_outDataw_ETC__q1 =
	     (x__h6359 | lut_serverAdapter_outData_outData$wget[4]) ?
	       4'd1 :
	       4'd0 ;
  assign ab__h1850 = 2'd0 ;
  assign lut_serverAdapter_cnt_6_PLUS_IF_lut_serverAdap_ETC___d32 =
	     lut_serverAdapter_cnt +
	     (lut_serverAdapter_cnt_1$whas ? 3'd1 : 3'd0) +
	     (MUX_lut_memory$put_1__SEL_1 ? 3'd7 : 3'd0) ;
  assign lut_serverAdapter_cnt_6_SLT_3___d61 =
	     (lut_serverAdapter_cnt ^ 3'h4) < 3'd7 ;
  assign x__h2618 = 32'd1 << x__h9373 ;
  assign x__h2677 = x__h2692 ^ y__h2693 ;
  assign x__h2692 = x__h2707 ^ y__h2708 ;
  assign x__h2707 = x__h2722 ^ y__h2723 ;
  assign x__h2722 =
	     lut_serverAdapter_outData_outData$wget[25] &
	     in[lut_serverAdapter_outData_outData$wget[24:20]] ;
  assign x__h2794 = in[lut_serverAdapter_outData_outData$wget[4:0]] ;
  assign x__h4435 = in[lut_serverAdapter_outData_outData$wget[9:5]] ;
  assign x__h6076 = in[lut_serverAdapter_outData_outData$wget[14:10]] ;
  assign x__h6359 = x__h6361 | lut_serverAdapter_outData_outData$wget[3] ;
  assign x__h6361 = x__h6363 | lut_serverAdapter_outData_outData$wget[2] ;
  assign x__h6363 =
	     lut_serverAdapter_outData_outData$wget[0] |
	     lut_serverAdapter_outData_outData$wget[1] ;
  assign x__h6699 = x__h6701 | lut_serverAdapter_outData_outData$wget[8] ;
  assign x__h6701 = x__h6703 | lut_serverAdapter_outData_outData$wget[7] ;
  assign x__h6703 =
	     lut_serverAdapter_outData_outData$wget[5] |
	     lut_serverAdapter_outData_outData$wget[6] ;
  assign x__h7043 = x__h7045 | lut_serverAdapter_outData_outData$wget[13] ;
  assign x__h7045 = x__h7047 | lut_serverAdapter_outData_outData$wget[12] ;
  assign x__h7047 =
	     lut_serverAdapter_outData_outData$wget[10] |
	     lut_serverAdapter_outData_outData$wget[11] ;
  assign x__h7717 = in[lut_serverAdapter_outData_outData$wget[19:15]] ;
  assign x__h9028 = x__h9030 | lut_serverAdapter_outData_outData$wget[18] ;
  assign x__h9030 = x__h9032 | lut_serverAdapter_outData_outData$wget[17] ;
  assign x__h9032 =
	     lut_serverAdapter_outData_outData$wget[15] |
	     lut_serverAdapter_outData_outData$wget[16] ;
  assign x__h9373 = row_num - 5'd1 ;
  assign y__h2678 = x__h7717 & y__h7718 ;
  assign y__h2693 = x__h6076 & y__h6077 ;
  assign y__h2708 = x__h4435 & y__h4436 ;
  assign y__h2723 =
	     x__h2794 &
	     IF_x359_OR_lut_serverAdapter_outData_outDataw_ETC__q1[0] ;
  assign y__h4436 = x__h6699 | lut_serverAdapter_outData_outData$wget[9] ;
  assign y__h6077 = x__h7043 | lut_serverAdapter_outData_outData$wget[14] ;
  assign y__h7718 = x__h9028 | lut_serverAdapter_outData_outData$wget[19] ;
  assign y__h9394 = ~x__h2618 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        in <= `BSV_ASSIGNMENT_DELAY 32'd0;
	lut_serverAdapter_cnt <= `BSV_ASSIGNMENT_DELAY 3'd0;
	lut_serverAdapter_s1 <= `BSV_ASSIGNMENT_DELAY 2'd0;
	out <= `BSV_ASSIGNMENT_DELAY 32'd0;
	row_num <= `BSV_ASSIGNMENT_DELAY 5'd0;
	state <= `BSV_ASSIGNMENT_DELAY 2'd0;
      end
    else
      begin
        if (in$EN) in <= `BSV_ASSIGNMENT_DELAY in$D_IN;
	if (lut_serverAdapter_cnt$EN)
	  lut_serverAdapter_cnt <= `BSV_ASSIGNMENT_DELAY
	      lut_serverAdapter_cnt$D_IN;
	if (lut_serverAdapter_s1$EN)
	  lut_serverAdapter_s1 <= `BSV_ASSIGNMENT_DELAY
	      lut_serverAdapter_s1$D_IN;
	if (out$EN) out <= `BSV_ASSIGNMENT_DELAY out$D_IN;
	if (row_num$EN) row_num <= `BSV_ASSIGNMENT_DELAY row_num$D_IN;
	if (state$EN) state <= `BSV_ASSIGNMENT_DELAY state$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    in = 32'hAAAAAAAA;
    lut_serverAdapter_cnt = 3'h2;
    lut_serverAdapter_s1 = 2'h2;
    out = 32'hAAAAAAAA;
    row_num = 5'h0A;
    state = 2'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_initiateBMVM)
	$display("Request Recevived %s", "../ELL_BMVM/LUT/ell4.mem");
    if (RST_N != `BSV_RESET_VALUE)
      if (lut_serverAdapter_s1[1] && !lut_serverAdapter_outDataCore$FULL_N)
	$display("ERROR: %m: mkBRAMSeverAdapter overrun");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_receive && (row_num != 5'd0 || state != 2'd2))
	$display("Row Entry Read: %0b",
		 lut_serverAdapter_outData_outData$wget);
  end
  // synopsys translate_on
endmodule  // mkEllBMVM

